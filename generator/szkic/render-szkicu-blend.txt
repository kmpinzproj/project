def sketch_and_export(model_name: str, export_path: str, file_format: str = 'PNG'):
    """
    Tworzy szkic modelu 3D i eksportuje go do pliku PNG lub JPG z dodatkowym oświetleniem i obudową.
    
    Args:
        model_name (str): Nazwa obiektu w Blenderze, który ma być wyrenderowany jako szkic.
        export_path (str): Ścieżka do katalogu wyjściowego (np. '/home/user/Desktop/').
        file_format (str): Format pliku wyjściowego ('PNG' lub 'JPEG').
        
    Returns:
        None
    """
    # Ustawienie silnika renderowania i formatu pliku
    bpy.context.scene.render.engine = 'BLENDER_EEVEE'  # Silnik EEVEE
    bpy.context.scene.render.image_settings.file_format = file_format  # Format pliku (PNG, JPEG)
    bpy.context.scene.render.film_transparent = False  # Brak przezroczystości

    # Wybór obiektu do szkicowania
    obj = bpy.data.objects.get(model_name)
    if obj is None:
        print(f"Obiekt '{model_name}' nie został znaleziony w scenie.")
        return
    
    # Pobranie wymiarów obiektu
    dimensions = obj.dimensions
    max_dim = max(dimensions)
    center = obj.location  # Lokalizacja środka obiektu

    # Ustawienie katalogu wyjściowego
    output_directory = os.path.abspath(export_path)
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)

    # Kamera 1 (izometryczna)
    camera_distance = max_dim * 3
    if 'Camera' not in bpy.data.objects:
        bpy.ops.object.camera_add()
    camera = bpy.data.objects['Camera']
    camera.location = (
        center[0] + camera_distance * 0.8,
        center[1] - camera_distance * 0.8,
        center[2] + max_dim * 0.7
    )
    camera.rotation_euler = (
        math.radians(77),  # Kąt kamery w osi X
        0,
        math.radians(45)
    )

    # Kamera 2 (widok z przodu)
    if 'Camera2' not in bpy.data.objects:
        bpy.ops.object.camera_add()
        bpy.context.object.name = 'Camera2'
    camera2 = bpy.data.objects['Camera2']
    camera2.location = (
        center[0],
        center[1] - max_dim * 4,
        1
    )
    camera2.rotation_euler = (
        math.radians(90),
        0,
        0
    )

    # Reflektor z przodu (Sun)
    if 'Sun' not in bpy.data.objects:
        bpy.ops.object.light_add(type='SPOT')
        bpy.context.object.name = 'Sun'
    sun = bpy.data.objects['Sun']
    sun.location = (
        center[0],
        center[1] + max_dim * 1.75,  # Centralnie z tyłu
        center[2] + max_dim * 3  # Na wysokości obiektu
    )
    sun.data.energy = 1800  # Łagodne światło
    sun.rotation_euler = (
        math.radians(00),  # Skierowane lekko w dół
        math.radians(0),
        math.radians(180)
    )
    sun.data.spot_size = math.radians(120)  # Stożek światła
    sun.data.shadow_soft_size = 1.0  # Miękkie cienie
    # Reflektor z przodu (Sun2)
    if 'Sun2' not in bpy.data.objects:
        bpy.ops.object.light_add(type='SPOT')
        bpy.context.object.name = 'Sun2'
    sun2 = bpy.data.objects['Sun2']
    sun2.location = (
        center[0],
        center[1] - max_dim * 2.5,  # Centralnie z przodu
        center[2] + max_dim * 3  # Na wysokości obiektu
    )
    sun2.data.energy = 1800  # Łagodne światło
    sun2.rotation_euler = (
        math.radians(30),  # Skierowane lekko w dół
        math.radians(0),
        0
    )
    sun2.data.spot_size = math.radians(150)  # Stożek światła
    sun2.data.shadow_soft_size = 1.0  # Miękkie cienie
    # Reflektor z przodu (Sun3)
    if 'Sun3' not in bpy.data.objects:
        bpy.ops.object.light_add(type='SPOT')
        bpy.context.object.name = 'Sun3'
    sun3 = bpy.data.objects['Sun3']
    sun3.location = (
        center[0] - max_dim * 2.5,
        center[1],  # Centralnie z przodu
        center[2] + max_dim * 3.5  # Na wysokości obiektu
    )
    sun3.data.energy = 1000  # Łagodne światło
    sun3.rotation_euler = (
        math.radians(30),  # Skierowane lekko w dół
        math.radians(0),
        math.radians(270)
    )
    sun3.data.spot_size = math.radians(50)  # Stożek światła
    sun3.data.shadow_soft_size = 1.0  # Miękkie cienie
    # Reflektor z przodu (Sun3)
    if 'Sun4' not in bpy.data.objects:
        bpy.ops.object.light_add(type='SPOT')
        bpy.context.object.name = 'Sun4'
    sun4 = bpy.data.objects['Sun4']
    sun4.location = (
        center[0] + max_dim * 2.5,
        center[1],  # Centralnie z przodu
        center[2] + max_dim * 3.5  # Na wysokości obiektu
    )
    sun4.data.energy = 1000  # Łagodne światło
    sun4.rotation_euler = (
        math.radians(30),  # Skierowane lekko w dół
        math.radians(0),
        math.radians(90)
    )
    sun4.data.spot_size = math.radians(50)  # Stożek światła
    sun4.data.shadow_soft_size = 1.0  # Miękkie cienie

    # Dodatkowe światło z boku (SideLight)
    if 'SideLight' not in bpy.data.objects:
        bpy.ops.object.light_add(type='AREA')
        bpy.context.object.name = 'SideLight'
    side_light = bpy.data.objects['SideLight']
    side_light.location = (
        center[0] + max_dim * 2,  # Z boku obiektu
        center[1],
        center[2]  # Na środku wysokości
    )
    side_light.data.energy = 500  # Rozproszone światło
    side_light.rotation_euler = (
        math.radians(0),
        math.radians(-90),  # Skierowane w stronę obiektu
        0
    )
        # Dodatkowe światło z przodu (FillLight1)
    if 'FillLight1' not in bpy.data.objects:
        bpy.ops.object.light_add(type='POINT')
        bpy.context.object.name = 'FillLight1'
    fill_light1 = bpy.data.objects['FillLight1']
    fill_light1.location = (
        center[0],
        center[1] - max_dim * 2,  # Przed obiektem
        center[2] + max_dim  # Na wysokości środka
    )
    fill_light1.data.energy = 500  # Średnia intensywność

    # Dodatkowe światło z lewej strony (FillLight2)
    if 'FillLight2' not in bpy.data.objects:
        bpy.ops.object.light_add(type='POINT')
        bpy.context.object.name = 'FillLight2'
    fill_light2 = bpy.data.objects['FillLight2']
    fill_light2.location = (
        center[0] - max_dim * 2,  # Lewa strona obiektu
        center[1],
        center[2] + max_dim * 0.5  # Na środku wysokości
    )
    fill_light2.data.energy = 500  # Mniejsza intensywność

    # Dodatkowe światło z prawej strony (FillLight3)
    if 'FillLight3' not in bpy.data.objects:
        bpy.ops.object.light_add(type='POINT')
        bpy.context.object.name = 'FillLight3'
    fill_light3 = bpy.data.objects['FillLight3']
    fill_light3.location = (
        center[0] + max_dim * 2,  # Prawa strona obiektu
        center[1],
        center[2] + max_dim * 0.5  # Na środku wysokości
    )
    fill_light3.data.energy = 500  # Mniejsza intensywność
    
    # Obudowanie płaszczyznami
    # Plane za obiektem
        # Materiał wspólny dla wszystkich płaszczyzn
    if 'PlaneMaterial' not in bpy.data.materials:
        mat = bpy.data.materials.new(name='PlaneMaterial')
        mat.use_nodes = True
        bsdf = mat.node_tree.nodes["Principled BSDF"]
        bsdf.inputs['Base Color'].default_value = (1, 1, 1, 1)  # Białe tło
        bsdf.inputs['Roughness'].default_value = 1.0  # Brak odbić
    else:
        mat = bpy.data.materials['PlaneMaterial']

    # Płaszczyzna tylna (BackPlane)
    if 'BackPlane' not in bpy.data.objects:
        bpy.ops.mesh.primitive_plane_add(size=max_dim * 6)
        back_plane = bpy.context.object
        back_plane.name = 'BackPlane'
        back_plane.location = (center[0], center[1] + max_dim * 2.5, center[2])
        back_plane.rotation_euler = (math.radians(90), 0, 0)
        back_plane.data.materials.append(mat)

    # Płaszczyzna boczna (SidePlane)
    if 'SidePlane' not in bpy.data.objects:
        bpy.ops.mesh.primitive_plane_add(size=max_dim * 6)
        side_plane = bpy.context.object
        side_plane.name = 'SidePlane'
        side_plane.location = (center[0] - max_dim * 3, center[1], center[2])
        side_plane.rotation_euler = (0, math.radians(90), 0)
        side_plane.data.materials.append(mat)
    # Płaszczyzna dolna (BottomPlane)
    if 'BottomPlane' not in bpy.data.objects:
        bpy.ops.mesh.primitive_plane_add(size=max_dim * 6)
        bottom_plane = bpy.context.object
        bottom_plane.name = 'BottomPlane'
        bottom_plane.location = (center[0], center[1], center[2] - dimensions[2] / 2 - 0.01)
        bottom_plane.rotation_euler = (0, 0, 0)
        bottom_plane.data.materials.append(mat)
    
        
    # Renderowanie z pierwszej kamery
    bpy.context.scene.camera = camera
    bpy.context.scene.render.filepath = os.path.join(output_directory, "render_camera1.png")
    bpy.ops.render.render(write_still=True)
    print(f"Render z kamery 1 zapisany jako: {os.path.join(output_directory, 'render_camera1.png')}")

    # Renderowanie z drugiej kamery
    bpy.context.scene.camera = camera2
    bpy.context.scene.render.filepath = os.path.join(output_directory, "render_camera2.png")
    bpy.ops.render.render(write_still=True)
    print(f"Render z kamery 2 zapisany jako: {os.path.join(output_directory, 'render_camera2.png')}")


# Przykładowe użycie metody
sketch_and_export(
    model_name='brama-uchylna-z-szynami',  # Nazwa obiektu 3D w Blenderze
    export_path='./tmp',  # Ścieżka do pliku wyjściowego
    file_format='PNG'  # Możliwe wartości: 'PNG', 'JPEG'
)