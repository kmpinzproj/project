# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F4pwQICvwYjDzxxQQ_20mk9ulJc4nzYV
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt

# Load the image
image_path = '/content/render_camera2.png'  # Replace with your image path
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Apply Gaussian blur to smooth the image
blurred_image = cv2.GaussianBlur(image, (5, 5), 0)

# Use adaptive thresholding to create a sketch effect
sketch = cv2.adaptiveThreshold(
    blurred_image,
    maxValue=255,
    adaptiveMethod=cv2.ADAPTIVE_THRESH_MEAN_C,
    thresholdType=cv2.THRESH_BINARY,
    blockSize=11,
    C=2
)

# Resize the sketch to fit within 1024x1024 with centering
target_size = 1024
object_height, object_width = sketch.shape

# Calculate scaling while keeping aspect ratio
aspect_ratio = object_width / object_height
if aspect_ratio > 1:
    new_width = target_size
    new_height = int(target_size / aspect_ratio)
else:
    new_height = target_size
    new_width = int(target_size * aspect_ratio)

resized_sketch = cv2.resize(sketch, (new_width, new_height), interpolation=cv2.INTER_AREA)

# Create a blank white canvas
canvas = np.ones((target_size, target_size), dtype=np.uint8) * 255

# Center the resized sketch on the canvas
y_offset = (target_size - new_height) // 2
x_offset = (target_size - new_width) // 2
canvas[y_offset:y_offset + new_height, x_offset:x_offset + new_width] = resized_sketch

# Save the final image without any arrows or lines
output_path = 'technical_sketch_without_dimensions.png'
cv2.imwrite(output_path, canvas)

# Display the result
plt.figure(figsize=(8, 8))
plt.axis('off')
plt.imshow(canvas, cmap='gray')
plt.title("Sketch Without Dimensions")
plt.show()

print(f"Final sketch saved at: {output_path}")

import cv2
import numpy as np
from PIL import Image, ImageDraw, ImageFont

# Load the image (convert to grayscale for edge detection)
image_path = "/content/technical_sketch_without_dimensions.png"
image = Image.open(image_path)
image_cv = np.array(image.convert('L'))  # Convert to grayscale for edge detection

# Step 1: Detect edges using Canny edge detection
edges = cv2.Canny(image_cv, threshold1=50, threshold2=150)

# Step 2: Find contours from the edges
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Step 3: Find the largest contour (assuming the main object is the largest one)
largest_contour = max(contours, key=cv2.contourArea)

# Step 4: Calculate the bounding box for the largest contour
x, y, w, h = cv2.boundingRect(largest_contour)
left_edge = x
right_edge = x + w
top_edge = y
bottom_edge = y + h

# Print the detected bounding box coordinates
print(f"Detected bounding box: Left={left_edge}, Right={right_edge}, Top={top_edge}, Bottom={bottom_edge}")
print(f"Object Width: {w} px, Object Height: {h} px")

# Create a copy of the image to draw on
bottom_width_arrow_image = image.copy()
draw = ImageDraw.Draw(bottom_width_arrow_image)

# Calculate arrow lengths
width_arrow_length = right_edge - left_edge
height_arrow_length = bottom_edge - top_edge

# Print the arrow lengths
print(f"Width arrow length: {width_arrow_length} pixels")
print(f"Height arrow length: {height_arrow_length} pixels")

# Load a font for text annotations
try:
    font = ImageFont.truetype("/content/arial.ttf", 16)  # UÅ¼yj poprawnej czcionki
except IOError:
    font = ImageFont.load_default()

# Draw a single black arrow for width at the bottom of the object, slightly lower
width_arrow_start_bottom = (left_edge, bottom_edge + 20)
width_arrow_end_bottom = (right_edge, bottom_edge + 20)
draw.line([width_arrow_start_bottom, width_arrow_end_bottom], fill="black", width=3)
draw.polygon([(left_edge + 10, bottom_edge + 15),
              (left_edge + 10, bottom_edge + 25),
              (left_edge, bottom_edge + 20)], fill="black")
draw.polygon([(right_edge - 10, bottom_edge + 15),
              (right_edge - 10, bottom_edge + 25),
              (right_edge, bottom_edge + 20)], fill="black")

# Add width annotation below the arrow
draw.text(((left_edge + right_edge) / 2 - 40, bottom_edge + 30),
          f"Width: {int(width_arrow_length)} px", fill="black", font=font)

# Draw a single black arrow for height (left of the object)
height_arrow_start_inverted = (left_edge - 20, top_edge)
height_arrow_end_inverted = (left_edge - 20, bottom_edge)
draw.line([height_arrow_start_inverted, height_arrow_end_inverted], fill="black", width=3)
draw.polygon([(left_edge - 25, top_edge + 10),
              (left_edge - 15, top_edge + 10),
              (left_edge - 20, top_edge)], fill="black")
draw.polygon([(left_edge - 25, bottom_edge - 10),
              (left_edge - 15, bottom_edge - 10),
              (left_edge - 20, bottom_edge)], fill="black")

# Add height annotation to the left of the arrow
draw.text((left_edge - 80, (top_edge + bottom_edge) / 2 - 10),
          f"Height: {int(height_arrow_length)} px", fill="black", font=font)

# Save the final image with the adjusted width arrow position
output_path = "adjusted_image_with_detected_arrows.png"
bottom_width_arrow_image.save(output_path)

# Display the path of the saved image
print(f"Image saved to {output_path}")